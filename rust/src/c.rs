// aws-greengrass-sdk-lite - Lightweight AWS IoT Greengrass SDK
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

//! Generated by bindgen

#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]
#![allow(clippy::pedantic)]

pub const GGL_OBJ_NULL: GglObject = GglObject { _private: [0; 11] };

pub type __time_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type GgIpcSubscribeToTopicCallback = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        topic: GglBuffer,
        payload: GglObject,
        handle: GgIpcSubscriptionHandle,
    ),
>;
pub type GgIpcSubscribeToIotCoreCallback = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        topic: GglBuffer,
        payload: GglBuffer,
        handle: GgIpcSubscriptionHandle,
    ),
>;
pub type GgIpcSubscribeToConfigurationUpdateCallback = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        component_name: GglBuffer,
        key_path: GglList,
        handle: GgIpcSubscriptionHandle,
    ),
>;
pub type GgIpcResultCallback = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        result: GglMap,
    ) -> GglError,
>;
pub type GgIpcErrorCallback = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        error_code: GglBuffer,
        message: GglBuffer,
    ) -> GglError,
>;
pub type GgIpcSubscribeCallback = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::core::ffi::c_void,
        aux_ctx: *mut ::core::ffi::c_void,
        handle: GgIpcSubscriptionHandle,
        service_model_type: GglBuffer,
        data: GglMap,
    ) -> GglError,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GglBuffer {
    pub data: *mut u8,
    pub len: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GglBufList {
    pub bufs: *mut GglBuffer,
    pub len: usize,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GglObject {
    pub _private: [u8; 11usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GglList {
    pub items: *mut GglObject,
    pub len: usize,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GglKV {
    pub _private: [u8; 21usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GglMap {
    pub pairs: *mut GglKV,
    pub len: usize,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GglArena {
    pub mem: *mut u8,
    pub capacity: u32,
    pub index: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GglArenaState {
    pub index: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct GgIpcSubscriptionHandle {
    pub val: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GglPresence {
    pub val: GglPresence__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GglMapSchemaEntry {
    pub key: GglBuffer,
    pub required: GglPresence,
    pub type_: GglObjectType,
    pub value: *mut *mut GglObject,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GglMapSchema {
    pub entries: *const GglMapSchemaEntry,
    pub entry_count: usize,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub const GGL_MAX_OBJECT_DEPTH: u32 = 15;
pub const GGL_MAX_OBJECT_SUBOBJECTS: u32 = 255;
pub const GGL_IPC_MAX_STREAMS: u32 = 16;
pub const GGL_IPC_RESPONSE_TIMEOUT: u32 = 10;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GglBuffer"][::core::mem::size_of::<GglBuffer>() - 16usize];
    ["Alignment of GglBuffer"][::core::mem::align_of::<GglBuffer>() - 8usize];
    ["Offset of field: GglBuffer::data"]
        [::core::mem::offset_of!(GglBuffer, data) - 0usize];
    ["Offset of field: GglBuffer::len"]
        [::core::mem::offset_of!(GglBuffer, len) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GglBufList"][::core::mem::size_of::<GglBufList>() - 16usize];
    ["Alignment of GglBufList"][::core::mem::align_of::<GglBufList>() - 8usize];
    ["Offset of field: GglBufList::bufs"]
        [::core::mem::offset_of!(GglBufList, bufs) - 0usize];
    ["Offset of field: GglBufList::len"]
        [::core::mem::offset_of!(GglBufList, len) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GglObject"][::core::mem::size_of::<GglObject>() - 11usize];
    ["Alignment of GglObject"][::core::mem::align_of::<GglObject>() - 1usize];
    ["Offset of field: GglObject::_private"]
        [::core::mem::offset_of!(GglObject, _private) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GglList"][::core::mem::size_of::<GglList>() - 16usize];
    ["Alignment of GglList"][::core::mem::align_of::<GglList>() - 8usize];
    ["Offset of field: GglList::items"]
        [::core::mem::offset_of!(GglList, items) - 0usize];
    ["Offset of field: GglList::len"]
        [::core::mem::offset_of!(GglList, len) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GglKV"][::core::mem::size_of::<GglKV>() - 21usize];
    ["Alignment of GglKV"][::core::mem::align_of::<GglKV>() - 1usize];
    ["Offset of field: GglKV::_private"]
        [::core::mem::offset_of!(GglKV, _private) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GglMap"][::core::mem::size_of::<GglMap>() - 16usize];
    ["Alignment of GglMap"][::core::mem::align_of::<GglMap>() - 8usize];
    ["Offset of field: GglMap::pairs"]
        [::core::mem::offset_of!(GglMap, pairs) - 0usize];
    ["Offset of field: GglMap::len"]
        [::core::mem::offset_of!(GglMap, len) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GglArena"][::core::mem::size_of::<GglArena>() - 16usize];
    ["Alignment of GglArena"][::core::mem::align_of::<GglArena>() - 8usize];
    ["Offset of field: GglArena::mem"]
        [::core::mem::offset_of!(GglArena, mem) - 0usize];
    ["Offset of field: GglArena::capacity"]
        [::core::mem::offset_of!(GglArena, capacity) - 8usize];
    ["Offset of field: GglArena::index"]
        [::core::mem::offset_of!(GglArena, index) - 12usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GglArenaState"][::core::mem::size_of::<GglArenaState>() - 4usize];
    ["Alignment of GglArenaState"]
        [::core::mem::align_of::<GglArenaState>() - 4usize];
    ["Offset of field: GglArenaState::index"]
        [::core::mem::offset_of!(GglArenaState, index) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GgIpcSubscriptionHandle"]
        [::core::mem::size_of::<GgIpcSubscriptionHandle>() - 4usize];
    ["Alignment of GgIpcSubscriptionHandle"]
        [::core::mem::align_of::<GgIpcSubscriptionHandle>() - 4usize];
    ["Offset of field: GgIpcSubscriptionHandle::val"]
        [::core::mem::offset_of!(GgIpcSubscriptionHandle, val) - 0usize];
};
pub const GglPresence_GGL_PRESENCE_REQUIRED: GglPresence__bindgen_ty_1 =
    GglPresence__bindgen_ty_1::GGL_PRESENCE_REQUIRED;
pub const GglPresence_GGL_PRESENCE_OPTIONAL: GglPresence__bindgen_ty_1 =
    GglPresence__bindgen_ty_1::GGL_PRESENCE_OPTIONAL;
pub const GglPresence_GGL_PRESENCE_MISSING: GglPresence__bindgen_ty_1 =
    GglPresence__bindgen_ty_1::GGL_PRESENCE_MISSING;
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GglPresence"][::core::mem::size_of::<GglPresence>() - 4usize];
    ["Alignment of GglPresence"]
        [::core::mem::align_of::<GglPresence>() - 4usize];
    ["Offset of field: GglPresence::val"]
        [::core::mem::offset_of!(GglPresence, val) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GglMapSchemaEntry"]
        [::core::mem::size_of::<GglMapSchemaEntry>() - 32usize];
    ["Alignment of GglMapSchemaEntry"]
        [::core::mem::align_of::<GglMapSchemaEntry>() - 8usize];
    ["Offset of field: GglMapSchemaEntry::key"]
        [::core::mem::offset_of!(GglMapSchemaEntry, key) - 0usize];
    ["Offset of field: GglMapSchemaEntry::required"]
        [::core::mem::offset_of!(GglMapSchemaEntry, required) - 16usize];
    ["Offset of field: GglMapSchemaEntry::type_"]
        [::core::mem::offset_of!(GglMapSchemaEntry, type_) - 20usize];
    ["Offset of field: GglMapSchemaEntry::value"]
        [::core::mem::offset_of!(GglMapSchemaEntry, value) - 24usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of GglMapSchema"][::core::mem::size_of::<GglMapSchema>() - 16usize];
    ["Alignment of GglMapSchema"]
        [::core::mem::align_of::<GglMapSchema>() - 8usize];
    ["Offset of field: GglMapSchema::entries"]
        [::core::mem::offset_of!(GglMapSchema, entries) - 0usize];
    ["Offset of field: GglMapSchema::entry_count"]
        [::core::mem::offset_of!(GglMapSchema, entry_count) - 8usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::core::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::core::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"]
        [::core::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"]
        [::core::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GglError {
    GGL_ERR_OK = 0,
    GGL_ERR_FAILURE = 1,
    GGL_ERR_RETRY = 2,
    GGL_ERR_BUSY = 3,
    GGL_ERR_FATAL = 4,
    GGL_ERR_INVALID = 5,
    GGL_ERR_UNSUPPORTED = 6,
    GGL_ERR_PARSE = 7,
    GGL_ERR_RANGE = 8,
    GGL_ERR_NOMEM = 9,
    GGL_ERR_NOCONN = 10,
    GGL_ERR_NODATA = 11,
    GGL_ERR_NOENTRY = 12,
    GGL_ERR_CONFIG = 13,
    GGL_ERR_REMOTE = 14,
    GGL_ERR_EXPECTED = 15,
    GGL_ERR_TIMEOUT = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GglObjectType {
    GGL_TYPE_NULL = 0,
    GGL_TYPE_BOOLEAN = 1,
    GGL_TYPE_I64 = 2,
    GGL_TYPE_F64 = 3,
    GGL_TYPE_BUF = 4,
    GGL_TYPE_LIST = 5,
    GGL_TYPE_MAP = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GglComponentState {
    GGL_COMPONENT_STATE_RUNNING = 0,
    GGL_COMPONENT_STATE_ERRORED = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum GglPresence__bindgen_ty_1 {
    GGL_PRESENCE_REQUIRED = 0,
    GGL_PRESENCE_OPTIONAL = 1,
    GGL_PRESENCE_MISSING = 2,
}
impl Default for GglBuffer {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for GglBufList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for GglList {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for GglMap {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for GglArena {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for GglPresence {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for GglMapSchemaEntry {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for GglMapSchema {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn ggl_strerror(err: GglError) -> *const ::core::ffi::c_char;
}
unsafe extern "C" {
    pub fn ggl_buffer_from_null_term(
        str_: *mut ::core::ffi::c_char,
    ) -> GglBuffer;
}
unsafe extern "C" {
    pub fn ggl_buffer_eq(buf1: GglBuffer, buf2: GglBuffer) -> bool;
}
unsafe extern "C" {
    pub fn ggl_buffer_has_prefix(buf: GglBuffer, prefix: GglBuffer) -> bool;
}
unsafe extern "C" {
    pub fn ggl_buffer_remove_prefix(
        buf: *mut GglBuffer,
        prefix: GglBuffer,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ggl_buffer_has_suffix(buf: GglBuffer, suffix: GglBuffer) -> bool;
}
unsafe extern "C" {
    pub fn ggl_buffer_remove_suffix(
        buf: *mut GglBuffer,
        suffix: GglBuffer,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ggl_buffer_contains(
        buf: GglBuffer,
        substring: GglBuffer,
        start: *mut usize,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ggl_buffer_substr(
        buf: GglBuffer,
        start: usize,
        end: usize,
    ) -> GglBuffer;
}
unsafe extern "C" {
    pub fn ggl_str_to_int64(str_: GglBuffer, value: *mut i64) -> GglError;
}
unsafe extern "C" {
    pub fn ggl_buf_copy(source: GglBuffer, target: *mut GglBuffer) -> GglError;
}
unsafe extern "C" {
    pub fn ggl_obj_type(obj: GglObject) -> GglObjectType;
}
unsafe extern "C" {
    pub fn ggl_obj_bool(value: bool) -> GglObject;
}
unsafe extern "C" {
    pub fn ggl_obj_into_bool(boolean: GglObject) -> bool;
}
unsafe extern "C" {
    pub fn ggl_obj_i64(value: i64) -> GglObject;
}
unsafe extern "C" {
    pub fn ggl_obj_into_i64(i64_: GglObject) -> i64;
}
unsafe extern "C" {
    pub fn ggl_obj_f64(value: f64) -> GglObject;
}
unsafe extern "C" {
    pub fn ggl_obj_into_f64(f64_: GglObject) -> f64;
}
unsafe extern "C" {
    pub fn ggl_obj_buf(value: GglBuffer) -> GglObject;
}
unsafe extern "C" {
    pub fn ggl_obj_into_buf(buf: GglObject) -> GglBuffer;
}
unsafe extern "C" {
    pub fn ggl_obj_map(value: GglMap) -> GglObject;
}
unsafe extern "C" {
    pub fn ggl_obj_into_map(map: GglObject) -> GglMap;
}
unsafe extern "C" {
    pub fn ggl_obj_list(value: GglList) -> GglObject;
}
unsafe extern "C" {
    pub fn ggl_obj_into_list(list: GglObject) -> GglList;
}
unsafe extern "C" {
    pub fn ggl_obj_mem_usage(obj: GglObject, size: *mut usize) -> GglError;
}
unsafe extern "C" {
    pub fn ggl_arena_init(buf: GglBuffer) -> GglArena;
}
unsafe extern "C" {
    pub fn ggl_arena_alloc(
        arena: *mut GglArena,
        size: usize,
        alignment: usize,
    ) -> *mut ::core::ffi::c_void;
}
unsafe extern "C" {
    pub fn ggl_arena_resize_last(
        arena: *mut GglArena,
        ptr: *const ::core::ffi::c_void,
        old_size: usize,
        size: usize,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggl_arena_owns(
        arena: *const GglArena,
        ptr: *const ::core::ffi::c_void,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ggl_arena_alloc_rest(arena: *mut GglArena) -> GglBuffer;
}
unsafe extern "C" {
    pub fn ggl_arena_claim_obj(
        obj: *mut GglObject,
        arena: *mut GglArena,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggl_arena_claim_buf(
        buf: *mut GglBuffer,
        arena: *mut GglArena,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggl_arena_claim_obj_bufs(
        obj: *mut GglObject,
        arena: *mut GglArena,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_connect() -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_connect_with_token(
        socket_path: GglBuffer,
        auth_token: GglBuffer,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_close_subscription(handle: GgIpcSubscriptionHandle);
}
unsafe extern "C" {
    pub fn ggipc_publish_to_topic_json(
        topic: GglBuffer,
        payload: GglMap,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_publish_to_topic_binary(
        topic: GglBuffer,
        payload: GglBuffer,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_publish_to_topic_binary_b64(
        topic: GglBuffer,
        b64_payload: GglBuffer,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_subscribe_to_topic(
        topic: GglBuffer,
        callback: GgIpcSubscribeToTopicCallback,
        ctx: *mut ::core::ffi::c_void,
        handle: *mut GgIpcSubscriptionHandle,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_publish_to_iot_core(
        topic_name: GglBuffer,
        payload: GglBuffer,
        qos: u8,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_publish_to_iot_core_b64(
        topic_name: GglBuffer,
        b64_payload: GglBuffer,
        qos: u8,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_subscribe_to_iot_core(
        topic_filter: GglBuffer,
        qos: u8,
        callback: GgIpcSubscribeToIotCoreCallback,
        ctx: *mut ::core::ffi::c_void,
        handle: *mut GgIpcSubscriptionHandle,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_get_config(
        key_path: GglBufList,
        component_name: *const GglBuffer,
        alloc: *mut GglArena,
        value: *mut GglObject,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_get_config_str(
        key_path: GglBufList,
        component_name: *const GglBuffer,
        value: *mut GglBuffer,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_update_config(
        key_path: GglBufList,
        timestamp: *const timespec,
        value_to_merge: GglObject,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_update_state(state: GglComponentState) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_restart_component(component_name: GglBuffer) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_subscribe_to_configuration_update(
        component_name: *const GglBuffer,
        key_path: GglBufList,
        callback: GgIpcSubscribeToConfigurationUpdateCallback,
        ctx: *mut ::core::ffi::c_void,
        handle: *mut GgIpcSubscriptionHandle,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_call(
        operation: GglBuffer,
        service_model_type: GglBuffer,
        params: GglMap,
        result_callback: GgIpcResultCallback,
        error_callback: GgIpcErrorCallback,
        response_ctx: *mut ::core::ffi::c_void,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggipc_subscribe(
        operation: GglBuffer,
        service_model_type: GglBuffer,
        params: GglMap,
        result_callback: GgIpcResultCallback,
        error_callback: GgIpcErrorCallback,
        response_ctx: *mut ::core::ffi::c_void,
        sub_callback: GgIpcSubscribeCallback,
        sub_callback_ctx: *mut ::core::ffi::c_void,
        sub_callback_aux_ctx: *mut ::core::ffi::c_void,
        sub_handle: *mut GgIpcSubscriptionHandle,
    ) -> GglError;
}
unsafe extern "C" {
    pub fn ggl_map_get(
        map: GglMap,
        key: GglBuffer,
        result: *mut *mut GglObject,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ggl_map_get_path(
        map: GglMap,
        path: GglBufList,
        result: *mut *mut GglObject,
    ) -> bool;
}
unsafe extern "C" {
    pub fn ggl_kv(key: GglBuffer, val: GglObject) -> GglKV;
}
unsafe extern "C" {
    pub fn ggl_kv_key(kv: GglKV) -> GglBuffer;
}
unsafe extern "C" {
    pub fn ggl_kv_set_key(kv: *mut GglKV, key: GglBuffer);
}
unsafe extern "C" {
    pub fn ggl_kv_val(kv: *mut GglKV) -> *mut GglObject;
}
unsafe extern "C" {
    pub fn ggl_map_validate(map: GglMap, schema: GglMapSchema) -> GglError;
}
unsafe extern "C" {
    pub fn ggl_sdk_init();
}
